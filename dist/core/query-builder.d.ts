import { QueryResult } from '../types';
import { HttpClient } from './http-client';
import { AnalyticsModule } from '../modules/analytics';
export declare class QueryBuilder<T = any> {
    private httpClient;
    private tableName;
    private selectFields;
    private whereFilters;
    private orFilters;
    private orderByFields;
    private joinClauses;
    private limitValue?;
    private offsetValue?;
    private groupByFields;
    private havingFilters;
    private _analytics?;
    constructor(httpClient: HttpClient, tableName: string);
    select(...fields: string[]): this;
    where(conditions: Record<string, any>): this;
    where(field: string, value: any): this;
    where(field: string, operator: string, value: any): this;
    filter(conditions: Record<string, any>): this;
    filter(field: string, value: any): this;
    filter(field: string, operator: string, value: any): this;
    and(conditions: Record<string, any>): this;
    and(field: string, value: any): this;
    and(field: string, operator: string, value: any): this;
    eq(field: string, value: any): this;
    ne(field: string, value: any): this;
    gt(field: string, value: any): this;
    gte(field: string, value: any): this;
    lt(field: string, value: any): this;
    lte(field: string, value: any): this;
    like(field: string, value: string): this;
    ilike(field: string, value: string): this;
    in(field: string, values: any[]): this;
    notIn(field: string, values: any[]): this;
    isNull(field: string): this;
    isNotNull(field: string): this;
    between(field: string, min: any, max: any): this;
    notBetween(field: string, min: any, max: any): this;
    or(...conditions: Array<(qb: QueryBuilder<T>) => QueryBuilder<T>>): this;
    orWhere(conditions: Record<string, any>): this;
    orWhere(field: string, value: any): this;
    orWhere(field: string, operator: string, value: any): this;
    orderBy(field: string, direction?: 'asc' | 'desc'): this;
    join(table: string, on: string, type?: 'inner' | 'left' | 'right' | 'full'): this;
    leftJoin(table: string, on: string): this;
    rightJoin(table: string, on: string): this;
    innerJoin(table: string, on: string): this;
    fullJoin(table: string, on: string): this;
    limit(count: number): this;
    offset(count: number): this;
    groupBy(...fields: string[]): this;
    having(field: string, operator: string, value: any): this;
    paginate(page: number, pageSize?: number): this;
    execute(): Promise<QueryResult<T>>;
    findById(id: string | number): Promise<T | null>;
    first(): Promise<T | null>;
    count(): Promise<number>;
    exists(): Promise<boolean>;
    insert(data: Partial<T>): Promise<T>;
    insertMany(data: Partial<T>[]): Promise<T[]>;
    update(data: Partial<T>): Promise<T[]>;
    upsert(data: Partial<T>, conflictFields?: string[]): Promise<T>;
    delete(): Promise<{
        count: number;
    }>;
    search(query: string, options?: {
        fields?: string[];
        highlight?: boolean;
        limit?: number;
    }): Promise<QueryResult<T>>;
    analyticsQuery(options: {
        metrics: string[];
        dimensions?: string[];
        timeRange?: {
            start: Date;
            end: Date;
        };
        interval?: string;
        realtime?: boolean;
    }): Promise<any[]>;
    aggregate(functions: string[]): Promise<any>;
    sum(field: string): Promise<number>;
    avg(field: string): Promise<number>;
    min(field: string): Promise<any>;
    max(field: string): Promise<any>;
    get analytics(): AnalyticsModule;
    private buildQueryOptions;
    private buildQueryParams;
    clone(): QueryBuilder<T>;
}
